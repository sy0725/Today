# any 타입과 unknown 타입

타입 단언이 위험하다고 했지만 이번엔 최악의 위험성을 가진 any 타입을 설명하겠습니다.

any는 아시겠지만 정말 위험한 기능이고 올바른 사용법의 난이도는 더 높습니다.

## any 타입

any 타입은 한마디로 정의하면 `타입 검사를 무효화하는 타입` 즉 , 어떤 타입이 들어가도 에러가 발생하지 않습니다.

이는 타입스크립트를 사용하는 의미가 크게 줄어듭니다. 따라서 any 타입은 가급적 사용을 피해야 합니다.

초보자들은 컴파일 에러를 없애는 수단으로 any타입을 사용하는 경우가 많습니다. 이건 결코 피해야만 하는 문제입니다.
왜냐면 컴파일 에러는 문제를 감지해서 알려주는 존재로 , any로 컴파일 에러를 없애는 것은 실제로 문제가 남아있는데도 문제를 침묵시키는 셈이기 때문입니다.

타입스크립트의 장점 중 하는 자동 입력 기능이 있는데 , any를 사용하면 지원을 받지 못한다는 것 또한 any의 약점입니다.

그러므로 에러가 발생하면 받아들이고 any를 사용해서 고치는 습관을 없애야합니다.

## any와 비슷하지만 안전한 unknown 타입

다음을 소개할 것은 unknown 타입입니다. 이 타입은 무엇이든 넣을 수 있는 타입으로 any와 유사합니다. unknown은 무엇이 들어있는지 전혀 알 수 없다는 점에서 붙여진 이름입니다.

그렇다면 any와 다른점은 무엇일까 ?

그 차이점은 any는 타입 검사가 이뤄지지 않는다는 점이 특징이고 이 점은 any타입의 위험성의 원천이기도 했습니다.

한편 unknown 타입은 안에 무엇이 있는지 알 수 없다는 성질을 타입스크립트 컴파일러가 존중해 줍니다.

즉 unknown 타입의 값은 정체를 알 수 없어서 할 수 있는일이 제한됩니다.

```ts
function doNothing(val: unknown) {
  // Error : Object is of type 'unknown'
  const name = val.name;
  console.log(name);
}
```

실제로 unknown 타입에는 어떤 값이든 들어올 수 있으므로 name이라는 프로퍼티가 있을지 알 수 없다.
위의 예시처럼 val 이 null이나 undefined일 가능성도 있고 , 이 경우 런타임 에러가 발생하므로 위 예시에서 컴파일 에러를 내주는 것은 당연하다.

그렇다면 어떻게 사용해야 할까 ?? 기본적으로 유니온 타입처럼 타입 좁히기를 수생한다.

```ts
function useUnKnown(val: unknown) {
  if (typeof val === "string") {
    console.log("val은 문자열입니다.");
    console.log(val.slice(0, 5));
  } else {
    console.log("val은 문자열 외의 무언가 입니다.");
    console.log(val);
  }

  useUnKnown("foobar");
  useUnKnown(null);
}
```

하지만 타입 좁히기를 동원하더라도 unknown 타입의 값을 사용하기 어려울것입니다.

그렇다지만 무엇이 들어올지 전혀 알 수 없는 상황에 적합한 것은 unknown 타입 입니다. 따라서 알 수 없는 상황을 제외하고는 unknown을 붙혀선 안됩니다.
